
        TITLE   AHCIACC.ASM - AHCI Register/Memory Acccess Routines

;****************************************************************************
;****************************************************************************
;**                                                                        **
;**             (C)Copyright 1985-2012, American Megatrends, Inc.          **
;**                                                                        **
;**                          All Rights Reserved.                          **
;**                                                                        **
;**                 5555 Oakbrook Pkwy, Suite 200, Norcross, GA 30093      **
;**                                                                        **
;**                          Phone (770)-246-8600                          **
;**                                                                        **
;****************************************************************************
;****************************************************************************

;****************************************************************************
; $Header: /Alaska/SOURCE/Modules/AHCI/INT13/CSP/AHCIACC.ASM 9     8/02/12 8:14a Deepthins $
;
; $Revision: 9 $
;
; $Date: 8/02/12 8:14a $
;****************************************************************************

;----------------------------------------------------------------------------
;       INCLUDE FILES
;----------------------------------------------------------------------------
        include ahci.equ
        include haccess.equ
        include aint13.equ
        include token.equ

;----------------------------------------------------------------------------
;       EXTERNS USED
;----------------------------------------------------------------------------
.586p
OEM16_CSEG SEGMENT PARA PUBLIC 'CODE' USE16
        ASSUME cs:OEM16_CSEG, ds:OEM16_CSEG
;-------------------------------------------------------------------------
        PUBLIC AhciApiModuleStart
AhciApiModuleStart LABEL BYTE
        jmp     SHORT AhciCsm16Api
        dw      AhciDataStart - AhciApiModuleStart 


;----------------------------------------------------------------------------
; IMPORTANT: Do not put any OEM/CHIPSET code above this, the above code and
;            and data are at fixed locations.
;----------------------------------------------------------------------------

;-------------------------------------------------------------------------
;                       AHCI_CSM16_API_Start
;----------------------------------------------------------------------------
; This routine is implementation of the CSM16 API #7.
; Input:        CX      80h   - ReadRegisterDword call
;                       00h   - WriteRegisterDword call
;                       01h   - WaitForFisRecRun call
;               For read/write functions:
;                   SS:SP+3Eh (originally ESI)  HBA Base Address
;                   SS:SP+42h (originally EBX)  Port#, Register Offset
;                       Bit31-16 = Port# (0-based)
;                                  FFFF for Generic Host Control Register
;                       Bit15-0  = Register offset
;                   SS:SP+46h  (originally EAX) Data to be written
;               For WaitForFisRecRun function:
;                   No input
; Output:       NC      Successful
;                       EAX     Data read
;               CY      Error
; Register Usage: Do not destroy any register except EAX
;
;----------------------------------------------------------------------------
;
AhciCsm16Api  PROC FAR PUBLIC
; Adjust current IP so that the data offsets are valid
        call    $+3     ; Push curent IP
        pop     bx		; Get current IP in BX
        shr     bx, 4
        mov     ax, cs      ; Always x000h
        add     ax, bx      ; New CS
        push    ax
        mov     ax, OFFSET newOffset
        sub     ax, OFFSET AhciApiModuleStart
        push    ax
;        push    newOffset - AhciApiModuleStart
        retf            ; Execute from new CS:IP

newOffset:
        push    bp
        mov     bp, sp
        mov     eax, ss:[bp+48h]    ; Data to be written (ignored for Read function)
        mov     ebx, ss:[bp+44h]    ; Port#
        mov     esi, ss:[bp+40h]    ; HBA Base Address

        cmp     cx, 0
        jz      aca_WriteCall
        cmp     cx, 80h
        jnz     aca_WaitForFisRecRun
        call    ReadRegisterDword
        jmp     SHORT aca_Exit
aca_WaitForFisRecRun:
        call    WaitForFisRecRun
        jmp     SHORT aca_Exit
aca_WriteCall:
        call    WriteRegisterDword

aca_Exit:
        pop     bp

; Adjust sp as if we returned to csm16_func_ret
        add     sp, 4   ; cs:ip of F000:csm16_func_ret

; Save EAX, restore it after popad
        push    eax
        pop     ds
        pop     gs
;csm16_func_ret:
        popad
        push    gs
        push    ds
        pop     eax

        pop     gs
        pop     fs
        pop     es
        pop     ds

;csm16_exit:
        popf
        pop     ds
        pop     si
    
        add     sp, 2   ; Do not "pop ax", preserving return code

; Prepare for FAR return - fetch the CS and patch the segment for RETF
        mov     cx, WORD PTR ss:[bp+1ah]
        mov     WORD PTR ss:[bp+06h], cx
; Restore CX
        mov    cx, WORD PTR ss:[bp+18h] 
        mov    dx, WORD PTR ss:[bp+16h] ;Restore Dx

        pop     bp
        add     sp, 4
        clc
        retf    18

AhciCsm16Api  ENDP

;
;-------------------------------------------------------------------------
;                       ReadRegisterDword
;----------------------------------------------------------------------------
; This routine reads the register.
; Input:        ESI     HBA Base Address
;               EBX     Port#, Register Offset
;                       Bit31-16 = Port# (0-based)
;                                  FFFF for Generic Host Control Register
;                       Bit15-0  = Register offset
; Output:       NC      Successful
;                       EAX     Data read
;               CY      Error
; Register Usage: Do not destroy any register except EAX
;
;----------------------------------------------------------------------------
;
ReadRegisterDword_FAR   PROC    FAR     PUBLIC
        call    ReadRegisterDword       ; EAX = data read if read
        ret
ReadRegisterDword_FAR   ENDP

ReadRegisterDword       PROC    NEAR    PUBLIC
        push    esi
        call    CalculateRegisterOffset ; ESI = register offset from base

        push    dx                      ; Dx has the controller number
        cli
        push    bx                      ; Save bx value in stack
        push    ax                      ; Save ax value in stack
        mov     ax, 0
        mov     al, dl                  ; Move the controller no into al
        mov     bl, 8
        mul     bl                      ; Multiply it with 8 as AHCI_ACCESS\
                                        ; structure size is 8
        mov     bx, ax                  ; Move the offset into bx
        pop     ax                      ; Restore ax
IF (MKF_AHCIMMIOSMM_SUPPORT)
        push    ebx
        push    ecx        
        mov     ebx, dword ptr cs:[AhciDataStart - AhciApiModuleStart +4+bx] ;ebx=Data
        add     esi,ebx
        mov     cx,1                    ;Read Function
        call    AhciGenerateSwSMI 
        pop     ecx
        pop     ebx
        jmp     Read_done
ENDIF
        mov     dx, cs:[AhciDataStart - AhciApiModuleStart +bx]              ; DX = Index Port
        push    eax
        mov     eax, esi                ; EAX = register address
        out     dx, eax                 ; Write Address
        pop     eax

        mov     dx, cs:[AhciDataStart - AhciApiModuleStart +2+bx]              ; DX = Data Port
        in      eax, dx                 ; EAX = adat


Read_done:
        pop     bx
        clc                             ; NC, Successful
        pop     dx

        pop     esi
        ret
ReadRegisterDword       ENDP
;
;----------------------------------------------------------------------------
;                       WriteRegisterDword
;----------------------------------------------------------------------------
; This routine writes the register.
; Input:        ESI     HBA Base Address
;               EBX     Port#, Register Offset
;                       Bit31-16 = Port# (0-based)
;                                  FFFF for Generic Host Control Register
;                       Bit15-0  = Register offset
;               EAX     Data to be written
; Output:       NC      Successful
;               CY      Error
; Register Usage: Do not destroy any register
;
;----------------------------------------------------------------------------
;
WriteRegisterDword_FAR  PROC    FAR     PUBLIC
        call    WriteRegisterDword
        ret
WriteRegisterDword_FAR  ENDP

WriteRegisterDword      PROC    NEAR    PUBLIC
        push    esi
        call    CalculateRegisterOffset ; ESI = register offset from base

        push    dx                      ; Dx has the controller number
        cli
        push    bx                      ; Save bx value in stack
        push    ax                      ; Save ax value in stack
        mov     ax, 0
        mov     al, dl                  ; Move the controller no into al
        mov     bl, 8
        mul     bl                      ; Multiply it with 8 as AHCI_ACCESS\
                                        ; structure size is 8
        mov     bx, ax                  ; Move the offset into bx
        pop     ax                      ; Restore ax

IF (MKF_AHCIMMIOSMM_SUPPORT)
        push    ebx
        push    ecx
        mov     ebx, dword ptr cs:[AhciDataStart - AhciApiModuleStart +4+bx]
        add     esi,ebx
        mov     ebx,eax                 ;Write Value
        mov     cx,2                    ;Write Function
        call    AhciGenerateSwSMI 
        pop     ecx
        pop     ebx
        jmp     Write_done
ENDIF
        mov     dx, cs:[AhciDataStart - AhciApiModuleStart +bx]              ; DX = Index Port
        push    eax
        mov     eax, esi                ; EAX = register address
        out     dx, eax                 ; Write Address
        pop     eax

        mov     dx, cs:[AhciDataStart - AhciApiModuleStart +2+bx]              ; DX = Data Port
        out     dx, eax                 ; Write dword data

Write_done:
        pop     bx
        clc                             ; NC, Successful
        pop     dx

        pop     esi
        ret
WriteRegisterDword      ENDP
;
;----------------------------------------------------------------------------
;                       CalculateRegisterOffset
;----------------------------------------------------------------------------
; This routine calculates the register offset from HBA Base.
; Input:        EBX     Port#, Register Offset within Port
;                       Bit31-16 = Port# (0-based)
;                                  FFFF for Generic Host Control Register
;                       Bit15-0  = Register offset
; Output:       ESI     Register Offset from HBA Base
; Register Usage: Do not destroy any register except ESI
;
;----------------------------------------------------------------------------
;
CalculateRegisterOffset PROC    NEAR    PRIVATE
        push    cx
        push    ebx
        mov     cx, bx                  ; CX = register offset
        shr     ebx, 16                 ; BX = Port# (0-based)
        inc     bx                      ; Port# valid?
        jz      short cro_00            ; No
        dec     bx                      ; BX = Port# (0-based)
        shl     bx, PORT_REGISTER_SET_SIZE_N
        add     bx, PORT_REGISTER_START
cro_00:
        add     bx, cx                  ; BX = Port register offset from HBA base address
        movzx   esi, bx                 ; ESI = Port register offset from HBA base address
        pop     ebx
        pop     cx
        ret
CalculateRegisterOffset ENDP

;
;----------------------------------------------------------------------------
;                       WaitForFisRecRun
;----------------------------------------------------------------------------
; This routine executes HBA wait for FIS rec run code. If not
; implemented (just ret), AHCI INT13 code will execute the default routine.
; Implement this routine for different OEM/Chipset vendor and return 0 in AL
; to override the default routine execution.
;
; Output:       AH     0 if implemented
;
;----------------------------------------------------------------------------
;
WaitForFisRecRun    PROC NEAR PUBLIC
        ret
WaitForFisRecRun    ENDP

;<AMI_PHDR_START>
;----------------------------------------------------------------------------
;
; Procedure:    AhciGenerateSwSMI 
;
; Description:  Generate the Sw SMI to read the MMIO space.
;               if the system is in big real mode, read/write the MMIO space without 
;               SwSMI  
;
; Input:        Cx = 1 - Read MMIO
;               Cx=  2 - Write MMIO 
;               Eax= Value to write in MMIO for write MMIO 
;                    
; Output:       Eax- for Read MMIO 
;
; Modified:     Ds
;
;----------------------------------------------------------------------------
;<AMI_PHDR_END>
IF (MKF_AHCIMMIOSMM_SUPPORT)
AhciGenerateSwSMI    PROC NEAR PUBLIC
        call    Check_Big_Real_mode
        jc      NotBigReadMode
        push    es
        push    0
        pop     es

        cmp     cx,1
        je      ReadMmio
        mov     dword ptr es:[esi],eax  ;Write MMIO  
        pop     es
        ret
ReadMmio:
        mov     eax,dword ptr es:[esi]  ;Read MMIO
        pop     es
        ret
NotBigReadMode:

        mov     dx,MKF_SW_SMI_IO_ADDRESS     
        mov     al,MKF_AHCI_MMIO_SWSMI
        out     dx,al                   ;Generate Sw SMI to Read/Write MMIO
        jmp     $+2
        ret
AhciGenerateSwSMI    ENDP


;<AMI_PHDR_START>
;----------------------------------------------------------------------------
;
; Procedure:    Get_EBDA
;
; Description:  Get the EBDA Segment Address 
;
; Input:        None 
;                    
; Output:       DS: Ebda Segment 
;
; Modified:     Ds
;
;----------------------------------------------------------------------------
;<AMI_PHDR_END>
Get_EBDA PROC NEAR PUBLIC

    push    40h
    pop     ds
    mov     ds, ds:[0Eh]                ; DS - EBDA segment.
    ret

get_EBDA ENDP

;<AMI_PHDR_START>
;----------------------------------------------------------------------------
;
; Procedure:    Int0DHandler
;
; Description:  Exception 0D handler 
;
; Input:        None 
;                    
; Output:       Exception_flag Set
;
; Modified:     None
;
;----------------------------------------------------------------------------
;<AMI_PHDR_END>
Int0DHandler PROC NEAR PUBLIC
        push    ds
        call    Get_EBDA
        mov     byte ptr ds:[102h],1    ;Set the Flag in Ebda:102
        pop     ds
        pop     ax
        add     ax, 5                   ; Go to Next instruction that doesn't 
                                        ; cause Exception 
        push    ax
        iret
Int0DHandler  ENDP

;<AMI_PHDR_START>
;----------------------------------------------------------------------------
;
; Procedure:    Check_Big_Real_mode
;
; Description:  This function checks wheather system is in Big real mode
;
; Input:        None 
;                    
; Output:       Carry Set - Not in Big Real mode 
;               Carry Not Set- System is in Big Real mode                 
;
; Modified:     None
;
;----------------------------------------------------------------------------
;<AMI_PHDR_END>
Check_Big_Real_mode  PROC NEAR PUBLIC
        push    eax
        push    edi
        push    ebx
        push    es
        push    ds
        pushf
        cli

        call    Get_EBDA

        mov     byte ptr ds:[102h],0    ;EBDA:102

        push    0
        pop     es

        mov     eax, dword ptr es:[0Dh*4]
        push    eax
               
        push    cs                      ; Runtime segment
        push    offset cs:Int0DHandler
        pop     eax
        mov     dword ptr es:[0Dh*4], eax


        mov     edi,0100000h
        mov     eax,dword ptr es:[edi]
        cmp     byte ptr ds:[102h],1    ;Check the exception
        je      Real_mode

        mov     edi,0
        mov     ebx,dword ptr es:[edi]
        cmp     eax,ebx
        je      Real_mode

                                        ;Read ,Write test for above 1Mb area
        mov     edi,0100000h
        mov     ebx,dword ptr es:[edi]
        mov     eax,055AA55AAh
        mov     dword ptr es:[edi],eax
        mov     eax,dword ptr es:[edi]
        mov     dword ptr es:[edi],ebx
        cmp     eax,055AA55AAh
        jne     Real_mode
        pop     eax
        mov     dword ptr es:[0Dh*4], eax
        popf    
        clc                             ;System is in Big Real Mode
        jmp     Exit_Ret

Real_mode:
        pop     eax
        mov     dword ptr es:[0Dh*4], eax
        popf
        stc                             ;System is in Real Mode
Exit_Ret:
        pop     ds
        pop     es
        pop     ebx
        pop     edi
        pop     eax
        ret        
Check_Big_Real_mode  ENDP

ENDIF

AhciDataStart   label word
AhciAccess AHCI_ACCESS (MKF_AHCI_CONTROLLER_COUNT) dup (<>)

OEM16_CSEG ENDS

END
;****************************************************************************
;****************************************************************************
;**                                                                        **
;**             (C)Copyright 1985-2012, American Megatrends, Inc.          **
;**                                                                        **
;**                          All Rights Reserved.                          **
;**                                                                        **
;**                 5555 Oakbrook Pkwy, Suite 200, Norcross, GA 30093      **
;**                                                                        **
;**                          Phone (770)-246-8600                          **
;**                                                                        **
;****************************************************************************
;****************************************************************************
